"""

This script provides utility functions for generating image patches from high-resolution images and saving them into a compressed ZIP file format.
It is designed to work with images from the Prostate Cancer Grade Assessment (PANDA) dataset or with similar sets contsaining large histological images, 
where detailed analysis and unnecessary content require subdividing the images into smaller patches. It is based on iafoss approach (https://www.kaggle.com/code/iafoss/panda-16x128x128-tiles).

Key Features:
- Generates non-overlapping patches of a specified size from whole-slide images.
- Aggregates patches into a single ZIP file for easy storage and processing.
- Computes channel-wise statistics (mean and variance) for each patch.
- Uses concurrent processing to speed up patch generation and aggregation.

Data Specifications:
1. Input Images:
   - The input images should be in .tiff format. These images are often multi-resolution and multi-level, meaning they can be accessed at different resolutions depending on the application.
   - This script currently uses the second resolution level of the .tiff images (level 1). This level is a good balance between detail and computational efficiency.

2. CSV Metadata File:
   - A CSV file is used to specify the image IDs to be processed. The CSV file should contain:
     - A column named `image_id` that holds the unique identifier for each image.

Patch Extraction Process:
1. Padding and Reshaping:
   - Each image is padded to ensure that its dimensions are a multiple of the `patch_size`. This is to ensure that all patches have consistent sizes.
   - The image is then reshaped into smaller square regions (patches) of size `patch_size x patch_size`.

2. Sorting and Selection:
   - If the total number of extracted patches is greater than `n_patches`, the patches are sorted based on their brightness (sum of pixel values), and only the top `n_patches` are selected. This ensures that blank or mostly empty patches are excluded.

3. Saving Patches:
   - The selected patches are saved as individual .png files, either to a temporary directory or directly into a ZIP file, depending on the function being used.

Usage:
- Modify `csv_path` and `image_folder` paths to point to your data directory.
- Adjust `patch_size`, `n_patches`, and `patch_mode` based on your patching requirements.
- Run the script as a standalone program to generate and save patches in a ZIP file.

Parameters:
- `patch_size`: The size of each square patch (e.g., 256x256 pixels).
- `n_patches`: The number of patches to extract from each image.
- `patch_mode`: Padding mode (0 for no extra padding, 1 for center padding).

Dependencies:
- pandas
- numpy
- scikit-image
- OpenCV (cv2)
- tqdm
- concurrent.futures
- zipfile
- tempfile
- shutil
"""

import os
import pandas as pd
import numpy as np
import skimage.io
import cv2
import zipfile
from tqdm import tqdm
from concurrent.futures import ProcessPoolExecutor, as_completed
import tempfile
import shutil

"""
# Patches parameters
patch_size = 256
n_patches = 14
patch_mode = 0
"""

def get_patches(img, patch_size, n_patches, mode):
    """
    Generate patches from an image.
    
    Parameters:
        img (np.array): The input image from which to generate patches.
        patch_size (int): The size of each patch (width and height).
        n_patches (int): The total number of patches to generate.
        mode (int): Padding mode (0 for no padding, 1 for centered padding).
    
    Returns:
        list: A list of dictionaries, each containing a patch and its index.
    """
    result = []
    h, w, c = img.shape
    pad_h = (patch_size - h % patch_size) % patch_size + ((patch_size * mode) // 2)
    pad_w = (patch_size - w % patch_size) % patch_size + ((patch_size * mode) // 2)

    img_padded = np.pad(img, [[pad_h // 2, pad_h - pad_h // 2], [pad_w // 2, pad_w - pad_w // 2], [0, 0]], constant_values=255)
    img_reshaped = img_padded.reshape(
        img_padded.shape[0] // patch_size,
        patch_size,
        img_padded.shape[1] // patch_size,
        patch_size,
        c
    )

    img_reshaped = img_reshaped.transpose(0, 2, 1, 3, 4).reshape(-1, patch_size, patch_size, c)
    if len(img_reshaped) < n_patches:
        img_reshaped = np.pad(img_reshaped, [[0, n_patches - len(img_reshaped)], [0, 0], [0, 0], [0, 0]], constant_values=255)
    idxs = np.argsort(img_reshaped.reshape(img_reshaped.shape[0], -1).sum(-1))[:n_patches]
    img_reshaped = img_reshaped[idxs]

    for i in range(len(img_reshaped)):
        result.append({'img': img_reshaped[i], 'idx': i})
    return result

def save_patches_to_zip(patches, img_id, zip_path="train_patches.zip"):
    """
    Save the patches as .png files directly into a ZIP file.
    
    Parameters:
        patches (list): List of patches generated by the `get_patches` function.
        img_id (str): The ID of the original image, used to name the patches.
        zip_path (str): The path to the ZIP file where the patches will be saved.
    """
    with zipfile.ZipFile(zip_path, 'a') as zipf:  # Open the ZIP file in append mode
        for patch in patches:
            idx = patch['idx']
            img = patch['img']
            filename = f"{img_id}_{idx}.png"  # Naming format to ensure uniqueness
            # Convert the image to PNG format in memory
            _, img_encoded = cv2.imencode('.png', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
            # Save the encoded image directly into the ZIP file
            zipf.writestr(filename, img_encoded.tobytes())

def process_image_and_save_patches(img_id, tiff_file):
    """
    Process an image to generate patches and save them to a temporary directory.
    
    Parameters:
        img_id (str): The ID of the image being processed.
        tiff_file (str): The path to the TIFF image file.
    
    Returns:
        tuple: A tuple containing the path to the temporary directory with patches, and the calculated statistics.
    """
    image = skimage.io.MultiImage(tiff_file)[1]  # Load the image at the appropriate level
    patches = get_patches(image, patch_size, n_patches, patch_mode)
    temp_dir = tempfile.mkdtemp()  # Create a temporary directory for this image's patches
    
    stats = []  # To store statistics (mean, variance) for each patch
    for patch in patches:
        idx = patch['idx']
        img = patch['img']
        filename = f"{img_id}_{idx}.png"
        cv2.imwrite(os.path.join(temp_dir, filename), cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
        
        # Calculate and store channel-wise statistics
        patch_mean = np.mean(img, axis=(0, 1))
        patch_var = np.var(img, axis=(0, 1))
        stats.append((patch_mean, patch_var))
    
    return temp_dir, stats

def aggregate_patches_into_zip(temp_dirs, zip_path="train_patches.zip"):
    """
    Aggregate patches from temporary directories into a single ZIP file.
    
    Parameters:
        temp_dirs (list): List of temporary directories containing patches.
        zip_path (str): The path to the ZIP file where the patches will be saved.
    """
    with zipfile.ZipFile(zip_path, 'w') as zipf:
        for temp_dir in temp_dirs:
            for filename in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, filename)
                zipf.write(file_path, filename)
            shutil.rmtree(temp_dir)  # Clean up the temporary directory

if __name__ == "__main__":
    # Define user-specified paths and read input data
    # Assumes the following:
    # - A directory containing the images (image_folder)
    # - A CSV file (csv_path) with at least one column: 'image_id'
    
    image_folder = 'path_to_your_image_directory'  # Replace with your image directory path
    csv_path = 'path_to_your_csv_file.csv'         # Replace with your CSV file path
    df_train = pd.read_csv(csv_path)

    temp_dirs = []  # List to collect temporary directories
    all_stats = []  # To collect statistics from all patches

    # Use concurrent processing to handle multiple images simultaneously
    with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
        futures = [executor.submit(process_image_and_save_patches, row['image_id'], os.path.join(image_folder, f'{row["image_id"]}.tiff')) for index, row in df_train.iterrows()]
        
        for future in tqdm(as_completed(futures), total=len(futures)):
            temp_dir, stats = future.result()
            temp_dirs.append(temp_dir)  # Collect the path to the temporary directory
            all_stats.extend(stats)  # Aggregate statistics
    
    # Calculate overall statistics
    overall_means = np.mean([stat[0] for stat in all_stats], axis=0)
    overall_vars = np.mean([stat[1] for stat in all_stats], axis=0)
    overall_stds = np.sqrt(overall_vars)

    print(f"Overall Means per Channel: {overall_means}, Overall Stds per Channel: {overall_stds}")

    # Aggregate all patches into a single ZIP file
    aggregate_patches_into_zip(temp_dirs)

"""

This script provides utility functions for generating image tiles from high-resolution images and saving them into a compressed ZIP file format. It is designed to work 
with images from the Prostate Cancer Grade Assessment (PANDA) dataset or with similar large histological images where detailed analysis and unnecessary content require subdividing the images into smaller tiles. It is based on iafoss approach (https://www.kaggle.com/code/iafoss/panda-16x128x128-tiles).

Key Features:
- Generates non-overlapping tiles of a specified size from whole-slide images.
- Aggregates tiles into a single ZIP file for easy storage and processing.
- Computes channel-wise statistics (mean and variance) for each tile.
- Uses concurrent processing to speed up tile generation and aggregation.

Data Specifications:
1. Input Images:
   - The input images should be in .tiff format. These images are often multi-resolution and multi-level, meaning they can be accessed at different resolutions depending on the application.
   - This script currently uses the second resolution level of the .tiff images (level 1). This level is a good balance between detail and computational efficiency.

2. CSV Metadata File:
   - A CSV file is used to specify the image IDs to be processed. The CSV file should contain:
     - A column named `image_id` that holds the unique identifier for each image.

Tile Extraction Process:
1. Padding and Reshaping:
   - Each image is padded to ensure that its dimensions are a multiple of the `tile_size`. This is to ensure that all tiles have consistent sizes.
   - The image is then reshaped into smaller square regions (tiles) of size `tile_size x tile_size`.

2. Sorting and Selection:
   - If the total number of extracted tiles is greater than `n_tiles`, the tiles are sorted based on their brightness (sum of pixel values), and only the top `n_tiles` are selected. This ensures that blank or mostly empty tiles are excluded.

3. Saving Tiles:
   - The selected tiles are saved as individual .png files, either to a temporary directory or directly into a ZIP file, depending on the function being used.

Usage:
- Modify `csv_path` and `image_folder` paths to point to your data directory.
- Adjust `tile_size`, `n_tiles`, and `tile_mode` based on your tiling requirements.
- Run the script as a standalone program to generate and save tiles in a ZIP file.

Parameters:
- `tile_size`: The size of each square tile (e.g., 256x256 pixels).
- `n_tiles`: The number of tiles to extract from each image.
- `tile_mode`: Padding mode (0 for no extra padding, 1 for center padding).

Dependencies:
- pandas
- numpy
- scikit-image
- OpenCV (cv2)
- tqdm
- concurrent.futures
- zipfile
- tempfile
- shutil
"""

import os
import pandas as pd
import numpy as np
import skimage.io
import cv2
import zipfile
from tqdm import tqdm
from concurrent.futures import ProcessPoolExecutor, as_completed
import tempfile
import shutil

"""
# Tiling parameters
tile_size = 256
n_tiles = 14
tile_mode = 0
"""

def get_tiles(img, tile_size, n_tiles, mode):
    """
    Generate tiles from an image.
    
    Parameters:
        img (np.array): The input image from which to generate tiles.
        tile_size (int): The size of each tile (width and height).
        n_tiles (int): The total number of tiles to generate.
        mode (int): Padding mode (0 for no padding, 1 for centered padding).
    
    Returns:
        list: A list of dictionaries, each containing a tile and its index.
    """
    result = []
    h, w, c = img.shape
    pad_h = (tile_size - h % tile_size) % tile_size + ((tile_size * mode) // 2)
    pad_w = (tile_size - w % tile_size) % tile_size + ((tile_size * mode) // 2)

    img_padded = np.pad(img, [[pad_h // 2, pad_h - pad_h // 2], [pad_w // 2, pad_w - pad_w // 2], [0, 0]], constant_values=255)
    img_reshaped = img_padded.reshape(
        img_padded.shape[0] // tile_size,
        tile_size,
        img_padded.shape[1] // tile_size,
        tile_size,
        c
    )

    img_reshaped = img_reshaped.transpose(0, 2, 1, 3, 4).reshape(-1, tile_size, tile_size, c)
    if len(img_reshaped) < n_tiles:
        img_reshaped = np.pad(img_reshaped, [[0, n_tiles - len(img_reshaped)], [0, 0], [0, 0], [0, 0]], constant_values=255)
    idxs = np.argsort(img_reshaped.reshape(img_reshaped.shape[0], -1).sum(-1))[:n_tiles]
    img_reshaped = img_reshaped[idxs]

    for i in range(len(img_reshaped)):
        result.append({'img': img_reshaped[i], 'idx': i})
    return result

def save_tiles_to_zip(tiles, img_id, zip_path="train_patches.zip"):
    """
    Save the tiles as .png files directly into a ZIP file.
    
    Parameters:
        tiles (list): List of tiles generated by the `get_tiles` function.
        img_id (str): The ID of the original image, used to name the tiles.
        zip_path (str): The path to the ZIP file where the tiles will be saved.
    """
    with zipfile.ZipFile(zip_path, 'a') as zipf:  # Open the ZIP file in append mode
        for tile in tiles:
            idx = tile['idx']
            img = tile['img']
            filename = f"{img_id}_{idx}.png"  # Naming format to ensure uniqueness
            # Convert the image to PNG format in memory
            _, img_encoded = cv2.imencode('.png', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
            # Save the encoded image directly into the ZIP file
            zipf.writestr(filename, img_encoded.tobytes())

def process_image_and_save_tiles(img_id, tiff_file):
    """
    Process an image to generate tiles and save them to a temporary directory.
    
    Parameters:
        img_id (str): The ID of the image being processed.
        tiff_file (str): The path to the TIFF image file.
    
    Returns:
        tuple: A tuple containing the path to the temporary directory with tiles, and the calculated statistics.
    """
    image = skimage.io.MultiImage(tiff_file)[1]  # Load the image at the appropriate level
    tiles = get_tiles(image, tile_size, n_tiles, tile_mode)
    temp_dir = tempfile.mkdtemp()  # Create a temporary directory for this image's tiles
    
    stats = []  # To store statistics (mean, variance) for each tile
    for tile in tiles:
        idx = tile['idx']
        img = tile['img']
        filename = f"{img_id}_{idx}.png"
        cv2.imwrite(os.path.join(temp_dir, filename), cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
        
        # Calculate and store channel-wise statistics
        tile_mean = np.mean(img, axis=(0, 1))
        tile_var = np.var(img, axis=(0, 1))
        stats.append((tile_mean, tile_var))
    
    return temp_dir, stats

def aggregate_tiles_into_zip(temp_dirs, zip_path="train_patches.zip"):
    """
    Aggregate tiles from temporary directories into a single ZIP file.
    
    Parameters:
        temp_dirs (list): List of temporary directories containing tiles.
        zip_path (str): The path to the ZIP file where the tiles will be saved.
    """
    with zipfile.ZipFile(zip_path, 'w') as zipf:
        for temp_dir in temp_dirs:
            for filename in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, filename)
                zipf.write(file_path, filename)
            shutil.rmtree(temp_dir)  # Clean up the temporary directory

if __name__ == "__main__":
    # Define user-specified paths and read input data
    # Assumes the following:
    # - A directory containing the images (image_folder)
    # - A CSV file (csv_path) with at least one column: 'image_id'
    
    image_folder = 'path_to_your_image_directory'  # Replace with your image directory path
    csv_path = 'path_to_your_csv_file.csv'         # Replace with your CSV file path
    df_train = pd.read_csv(csv_path)

    temp_dirs = []  # List to collect temporary directories
    all_stats = []  # To collect statistics from all tiles

    # Use concurrent processing to handle multiple images simultaneously
    with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
        futures = [executor.submit(process_image_and_save_tiles, row['image_id'], os.path.join(image_folder, f'{row["image_id"]}.tiff')) for index, row in df_train.iterrows()]
        
        for future in tqdm(as_completed(futures), total=len(futures)):
            temp_dir, stats = future.result()
            temp_dirs.append(temp_dir)  # Collect the path to the temporary directory
            all_stats.extend(stats)  # Aggregate statistics
    
    # Calculate overall statistics
    overall_means = np.mean([stat[0] for stat in all_stats], axis=0)
    overall_vars = np.mean([stat[1] for stat in all_stats], axis=0)
    overall_stds = np.sqrt(overall_vars)

    print(f"Overall Means per Channel: {overall_means}, Overall Stds per Channel: {overall_stds}")

    # Aggregate all tiles into a single ZIP file
    aggregate_tiles_into_zip(temp_dirs)

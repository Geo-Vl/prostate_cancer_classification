"""
image_tiling.py

This script provides utility functions for generating image tiles from high-resolution
medical images and saving them into a compressed ZIP file format. It is designed to work 
with images from the Prostate Cancer Grade Assessment (PANDA) dataset or similar image datasets.

Key Features:
- Generates non-overlapping tiles of a specified size from whole-slide images.
- Aggregates tiles into a single ZIP file for easy storage and processing.
- Computes channel-wise statistics (mean and variance) for each tile.
- Uses concurrent processing to speed up tile generation and aggregation.

Usage:
- Modify `csv_path` and `image_folder` paths to point to your data directory.
- Adjust `tile_size`, `n_tiles`, and `tile_mode` based on your tiling requirements.
- Run the script as a standalone program to generate and save tiles in a ZIP file.

Dependencies:
- pandas
- numpy
- scikit-image
- OpenCV (cv2)
- tqdm
- concurrent.futures
"""

import os
import pandas as pd
import numpy as np
import skimage.io
import cv2
import zipfile
from tqdm import tqdm
from concurrent.futures import ProcessPoolExecutor, as_completed
import tempfile
import shutil

# Constants for tiling parameters
tile_size = 256
n_tiles = 14
tile_mode = 0

def get_tiles(img, tile_size, n_tiles, mode=0):
    """
    Generate tiles from an image.
    
    Parameters:
        img (np.array): The input image from which to generate tiles.
        tile_size (int): The size of each tile (width and height).
        n_tiles (int): The total number of tiles to generate.
        mode (int): Padding mode (0 for no padding, 1 for centered padding).
    
    Returns:
        list: A list of dictionaries, each containing a tile and its index.
    """
    result = []
    h, w, c = img.shape
    pad_h = (tile_size - h % tile_size) % tile_size + ((tile_size * mode) // 2)
    pad_w = (tile_size - w % tile_size) % tile_size + ((tile_size * mode) // 2)

    img_padded = np.pad(img, [[pad_h // 2, pad_h - pad_h // 2], [pad_w // 2, pad_w - pad_w // 2], [0, 0]], constant_values=255)
    img_reshaped = img_padded.reshape(
        img_padded.shape[0] // tile_size,
        tile_size,
        img_padded.shape[1] // tile_size,
        tile_size,
        c
    )

    img_reshaped = img_reshaped.transpose(0, 2, 1, 3, 4).reshape(-1, tile_size, tile_size, c)
    if len(img_reshaped) < n_tiles:
        img_reshaped = np.pad(img_reshaped, [[0, n_tiles - len(img_reshaped)], [0, 0], [0, 0], [0, 0]], constant_values=255)
    idxs = np.argsort(img_reshaped.reshape(img_reshaped.shape[0], -1).sum(-1))[:n_tiles]
    img_reshaped = img_reshaped[idxs]

    for i in range(len(img_reshaped)):
        result.append({'img': img_reshaped[i], 'idx': i})
    return result

def save_tiles_to_zip(tiles, img_id, zip_path="train_patches.zip"):
    """
    Save the tiles as .png files directly into a ZIP file.
    
    Parameters:
        tiles (list): List of tiles generated by the `get_tiles` function.
        img_id (str): The ID of the original image, used to name the tiles.
        zip_path (str): The path to the ZIP file where the tiles will be saved.
    """
    with zipfile.ZipFile(zip_path, 'a') as zipf:  # Open the ZIP file in append mode
        for tile in tiles:
            idx = tile['idx']
            img = tile['img']
            filename = f"{img_id}_{idx}.png"  # Naming format to ensure uniqueness
            # Convert the image to PNG format in memory
            _, img_encoded = cv2.imencode('.png', cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
            # Save the encoded image directly into the ZIP file
            zipf.writestr(filename, img_encoded.tobytes())

def process_image_and_save_tiles(img_id, tiff_file):
    """
    Process an image to generate tiles and save them to a temporary directory.
    
    Parameters:
        img_id (str): The ID of the image being processed.
        tiff_file (str): The path to the TIFF image file.
    
    Returns:
        tuple: A tuple containing the path to the temporary directory with tiles, and the calculated statistics.
    """
    image = skimage.io.MultiImage(tiff_file)[1]  # Load the image at the appropriate level
    tiles = get_tiles(image, tile_size, n_tiles, tile_mode)
    temp_dir = tempfile.mkdtemp()  # Create a temporary directory for this image's tiles
    
    stats = []  # To store statistics (mean, variance) for each tile
    for tile in tiles:
        idx = tile['idx']
        img = tile['img']
        filename = f"{img_id}_{idx}.png"
        cv2.imwrite(os.path.join(temp_dir, filename), cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
        
        # Calculate and store channel-wise statistics
        tile_mean = np.mean(img, axis=(0, 1))
        tile_var = np.var(img, axis=(0, 1))
        stats.append((tile_mean, tile_var))
    
    return temp_dir, stats

def aggregate_tiles_into_zip(temp_dirs, zip_path="train_patches.zip"):
    """
    Aggregate tiles from temporary directories into a single ZIP file.
    
    Parameters:
        temp_dirs (list): List of temporary directories containing tiles.
        zip_path (str): The path to the ZIP file where the tiles will be saved.
    """
    with zipfile.ZipFile(zip_path, 'w') as zipf:
        for temp_dir in temp_dirs:
            for filename in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, filename)
                zipf.write(file_path, filename)
            shutil.rmtree(temp_dir)  # Clean up the temporary directory

if __name__ == "__main__":
    # Define user-specified paths and read input data
    # Assumes the following:
    # - A directory containing the images (image_folder)
    # - A CSV file (csv_path) with at least one column: 'image_id'
    
    image_folder = 'path_to_your_image_directory'  # Replace with your image directory path
    csv_path = 'path_to_your_csv_file.csv'         # Replace with your CSV file path
    df_train = pd.read_csv(csv_path)

    temp_dirs = []  # List to collect temporary directories
    all_stats = []  # To collect statistics from all tiles

    # Use concurrent processing to handle multiple images simultaneously
    with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
        futures = [executor.submit(process_image_and_save_tiles, row['image_id'], os.path.join(image_folder, f'{row["image_id"]}.tiff')) for index, row in df_train.iterrows()]
        
        for future in tqdm(as_completed(futures), total=len(futures)):
            temp_dir, stats = future.result()
            temp_dirs.append(temp_dir)  # Collect the path to the temporary directory
            all_stats.extend(stats)  # Aggregate statistics
    
    # Calculate overall statistics
    overall_means = np.mean([stat[0] for stat in all_stats], axis=0)
    overall_vars = np.mean([stat[1] for stat in all_stats], axis=0)
    overall_stds = np.sqrt(overall_vars)

    print(f"Overall Means per Channel: {overall_means}, Overall Stds per Channel: {overall_stds}")

    # Aggregate all tiles into a single ZIP file
    aggregate_tiles_into_zip(temp_dirs)
